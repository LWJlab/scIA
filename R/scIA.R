#' Single-cell intelligent annotation
#' @author Fanjie Lin, Yuanfang Xie, Weiguo Kong, Ken Lin
#' \email{lfj@@stu.gzhmu.edu.cn}
#' @param object Seurat object.
#' @param org Organism
#' @param cell_ids Name of cells to be analyzed
#' @param ex_types Cell types to be excluded
#' @param gs List of gene markers
#' @param ci_gs List of gene markers' confidence
#' @param wt_gs List of gene markers' weight
#' @param pan_mapping Mapping cells to main cell types
#' @param include_gs Whether to print the gene expression in the results
#' @param use_pan Using pan-celltype mapping function
#' @param use_cluster Using cluster mapping function (Generated by FindClusters function)
#' @param cluster_ids Cluster ids of object (Generated by FindClusters function)
#' @param cluster_col The column name of cluster ids in metadata
#' @return A dataframe containing the final results
#' @export
#' @examples
#' scIA(sce, org = 'hsa', 
#' cell_ids = cell_ids, 
#' gs = gs, 
#' ex_types = c('Goblet (bronchial)','SMG duct','SMG mucous','SMG serous (bronchial)'), 
#' ci_gs = ci_gs,
#' wt_gs = wt_gs,
#' include_gs = FALSE,
#' pan_mapping = pan_celltype,
#' use_pan = FALSE,
#' use_cluster = TRUE,  
#' cluster_ids = cluster_ids,   
#' cluster_col = "seurat_clusters"
scIA <- function(object, 
                 org = c('hsa','mus','rat'),
                 cell_ids, 
                 ex_types = NULL,
                 gs = NULL, 
                 ci_gs = NULL,
                 wt_gs = NULL,
                 pan_mapping = NULL,
                 include_gs = FALSE,
                 use_pan = FALSE,
                 use_cluster = TRUE,
                 cluster_ids = NULL,
                 cluster_col = "seurat_clusters") {
  
  # 步骤0: 检查参数冲突
  if (use_pan && use_cluster) {
    stop("Cannot enable both use_pan and use_cluster simultaneously. ",
         "Please choose only one grouping method.")
  }
  
  # 初始化总进度条
  message("Starting cell type assignment...")
  pb_total <- txtProgressBar(min = 0, max = 6, style = 3, width = 50, char = "=")
  setTxtProgressBar(pb_total, 0)
  Sys.sleep(0.1)
  
  # 步骤1: 加载包
  message("\n[1/6] Loading required packages...")
  if (!require("Seurat", quietly = TRUE)) install.packages("Seurat")
  if (!require("dplyr", quietly = TRUE)) install.packages("dplyr")
  if (!require("matrixStats", quietly = TRUE)) install.packages("matrixStats")
  library(matrixStats)
  library(Seurat)
  library(dplyr)
  setTxtProgressBar(pb_total, 1)
  Sys.sleep(0.1)
  
  # 步骤2: 过滤排除的细胞类型
  message("\n[2/6] Filtering excluded cell types...")
  if (!is.null(ex_types)) {
    gs <- gs[!names(gs) %in% ex_types]
    message("Excluded cell types: ", paste(ex_types, collapse = ", "))
  }
  
  # 步骤2.5: 根据wt_gs更新标记基因列表 (新增步骤)
  if (!is.null(wt_gs)) {
    message("Updating gs with genes from wt_gs...")
    for (type in names(wt_gs)) {
      if (type %in% names(gs)) {
        # 添加不在基础标记中的新基因
        new_genes <- setdiff(names(wt_gs[[type]]), gs[[type]])
        if (length(new_genes) > 0) {
          gs[[type]] <- c(gs[[type]], new_genes)
          message("  Added ", length(new_genes), " genes to '", type, "'")
        }
      } else {
        warning("Cell type '", type, "' in wt_gs is not in gs Ignoring.")
      }
    }
  }
  
  # 获取表达矩阵
  expr_matrix <- GetAssayData(object, slot = "data")[, cell_ids, drop = FALSE]
  setTxtProgressBar(pb_total, 2)
  Sys.sleep(0.1)
  message("Retrieved expression matrix for ", length(cell_ids), " cells")
  
  # 步骤3: 计算pan-celltype分数
  message("\n[3/6] Calculating pan-celltype scores...")
  if (is.null(org)) {
    stop("org parameter must be specified as 'hsa' or 'mus'")
  } else if (!org %in% c("hsa", "mus")) {
    stop("Please input 'hsa' (human) or 'mus' (mouse) for org parameter.")
  }
  
  # 定义pan-celltype标记基因
  pan_genes <- if (org == 'hsa') {
    list(
      Pan_epithelial = c("EPCAM", "FXYD3", "ELF3"),
      Pan_endothelial = c("CLDN5", "ECSCR", "CLEC14A"),
      Pan_immune = c("PTPRC", "CD53", "CORO1A"),
      Pan_stroma = c("COL1A2", "DCN", "MFAP4")
    )
  } 
  pan_genes <- if (org %in% c('mus','rat')) {
    list(
      Pan_epithelial = c("Epcam", "Fxyd3", "Elf3"),
      Pan_endothelial = c("Cldn5", "Ecscr", "Clec14a"),
      Pan_immune = c("Ptprc", "Cd53", "Coro1a"),
      Pan_stroma = c("Col1a2", "Dcn", "Mfap4")
    )
  }
  
  # 计算pan-celltype分数
  pan_types <- names(pan_genes)
  pan_scores <- matrix(0, nrow = length(cell_ids), ncol = length(pan_types),
                       dimnames = list(cell_ids, pan_types))
  
  for (i in seq_along(pan_types)) {
    genes <- pan_genes[[i]]
    valid_genes <- intersect(genes, rownames(expr_matrix))
    if (length(valid_genes) > 0) {
      pan_scores[, i] <- colMeans(expr_matrix[valid_genes, , drop = FALSE])
    }
  }
  setTxtProgressBar(pb_total, 3)
  Sys.sleep(0.1)
  
  # 步骤4: 分组策略
  message("\n[4/6] Assigning cells to groups...")
  
  # 新增：用户组名到标准pan组名的映射
  standard_pan_names <- c("Pan_epithelial", "Pan_endothelial", "Pan_immune", "Pan_stroma")
  
  # 聚类分组处理
  if (use_cluster) {
    message("Using cluster-based grouping...")
    
    # 验证参数
    if (is.null(cluster_ids)) {
      stop("cluster_ids must be provided when use_cluster = TRUE")
    }
    
    if (!cluster_col %in% colnames(object@meta.data)) {
      stop("Cluster column '", cluster_col, "' not found in Seurat object metadata")
    }
    
    # 获取细胞的聚类信息
    cluster_vec <- as.character(object@meta.data[cell_ids, cluster_col])
    names(cluster_vec) <- cell_ids
    
    # 检查所有聚类是否都有定义
    missing_clusters <- setdiff(unique(cluster_vec), names(cluster_ids))
    if (length(missing_clusters) > 0) {
      stop("The following clusters are missing in cluster_ids: ", 
           paste(missing_clusters, collapse = ", "))
    }
    
    # 为每个细胞分配组
    pan_groups <- sapply(cluster_vec, function(clust) {
      groups <- cluster_ids[[clust]]
      if (is.null(groups) || length(groups) == 0) {
        return("All_celltypes")
      } else {
        # 验证组名是否为标准pan组名
        if (any(!groups %in% standard_pan_names)) {
          stop("Invalid group name(s) in cluster_ids: ", 
               paste(setdiff(groups, standard_pan_names), collapse = ", "),
               "\nValid group names are: ", paste(standard_pan_names, collapse = ", "))
        }
        return(paste(sort(groups), collapse = "&"))
      }
    })
    
    # 分组统计
    group_counts <- table(pan_groups)
    message("Cell distribution across cluster-based groups:")
    for (i in seq_along(group_counts)) {
      message("  ", names(group_counts)[i], ": ", group_counts[i], " cells")
    }
  } 
  # pan分组处理
  else if (use_pan) {
    message("Using pan-celltype-based grouping...")
    
    # 检查并补全pan_mapping
    missing_pan <- setdiff(pan_types, names(pan_mapping))
    if (length(missing_pan) > 0) {
      warning("The following pan-celltype groups are missing in pan_mapping: ",
              paste(missing_pan, collapse = ", "))
      for (p in missing_pan) {
        pan_mapping[[p]] <- character(0)
      }
    }
    
    # 创建pan_group分配
    pan_groups <- apply(pan_scores, 1, function(scores) {
      non_zero_types <- names(which(scores > 0))
      
      if (length(non_zero_types) == 0) {
        return("All_celltypes")
      } else if (length(non_zero_types) == 1) {
        return(non_zero_types)
      } else {
        return(paste(sort(non_zero_types), collapse = "&"))
      }
    })
    
    # 分组统计
    group_counts <- table(pan_groups)
    message("Cell distribution across pan-celltype groups:")
    for (i in seq_along(group_counts)) {
      message("  ", names(group_counts)[i], ": ", group_counts[i], " cells")
    }
  } 
  # 默认分组
  else {
    message("No grouping strategy used - all cells in 'All_celltypes' group")
    pan_groups <- rep("All_celltypes", length(cell_ids))
    names(pan_groups) <- cell_ids
    message("All cells assigned to 'All_celltypes' group")
  }
  
  # 存储所有分组结果
  results_list <- list()
  setTxtProgressBar(pb_total, 4)
  Sys.sleep(0.1)
  
  # 步骤5: 对每个大类/混合类单独进行预测
  message("\n[5/6] Performing cell type prediction for each group...")
  unique_groups <- unique(pan_groups)
  
  for (group in unique_groups) {
    message("\nProcessing group: ", group)
    
    # 获取当前组的细胞ID
    group_cell_ids <- names(pan_groups)[pan_groups == group]
    message("  Number of cells: ", length(group_cell_ids))
    
    # 确定该组需要预测的细胞类型
    if (group == "All_celltypes") {
      # 情况: 使用所有细胞类型进行预测
      valid_celltypes <- names(gs)
      message("  Predicting across ALL cell types: ", paste(valid_celltypes, collapse = ", "))
    } else {
      # 确定该组包含的pan大类
      pan_categories <- unlist(strsplit(group, "&"))
      
      # 获取该组需要预测的细胞类型 (取并集)
      valid_celltypes <- unique(unlist(pan_mapping[pan_categories]))
      valid_celltypes <- intersect(valid_celltypes, names(gs))
      
      if (length(valid_celltypes) == 0) {
        message("  No valid cell types found for group - using all cell types")
        valid_celltypes <- names(gs)
      }
      message("  Cell types to predict: ", paste(valid_celltypes, collapse = ", "))
    }
    
    if (length(valid_celltypes) == 0) {
      warning("No valid cell types found for group: ", group)
      # 创建默认结果
      group_results <- data.frame(
        cell_id = group_cell_ids,
        predicted.label = "Unassigned_in_group",
        predicted.score = 0,
        stringsAsFactors = FALSE
      )
    } else {
      # 提取子集的gs和wt_gs
      sub_markers <- gs[valid_celltypes]
      sub_weights <- if (!is.null(wt_gs)) {
        wt_gs[intersect(names(wt_gs), valid_celltypes)]
      } else {
        NULL
      }
      
      # 计算该组的细胞类型概率
      group_results <- .cal_prob(
        expr_matrix = expr_matrix[, group_cell_ids, drop = FALSE],
        gs = sub_markers,
        wt_gs = sub_weights,
        pan_scores = pan_scores[group_cell_ids, , drop = FALSE]
      )
    }
    
    # 保存结果
    results_list[[group]] <- list(
      cells = group_cell_ids,
      results = group_results
    )
    message("  Completed prediction for group: ", group)
  }
  
  setTxtProgressBar(pb_total, 5)
  Sys.sleep(0.1)
  
  # 步骤6: 整合所有结果
  message("\n[6/6] Merging results and creating final output...")
  
  # 创建空的结果数据框
  final_df <- data.frame(
    cell_id = cell_ids,
    stringsAsFactors = FALSE
  )
  
  # 添加pan-celltype分数
  final_df <- cbind(final_df, as.data.frame(pan_scores[cell_ids, ]))
  
  # 添加分组信息
  final_df$group <- pan_groups[cell_ids]
  
  # 如果使用聚类分组，添加cluster列
  if (use_cluster) {
    # 获取细胞的聚类信息
    cluster_vec <- as.character(object@meta.data[cell_ids, cluster_col])
    final_df$cluster <- cluster_vec
  }
  
  # 初始化最终预测标签和分数
  final_df$predicted.label <- NA
  final_df$predicted.score <- NA
  
  # 添加每个细胞的详细预测结果
  for (group in names(results_list)) {
    group_data <- results_list[[group]]$results
    group_cells <- results_list[[group]]$cells
    
    # 提取该组的预测标签和分数
    group_labels <- group_data$predicted.label
    group_scores <- group_data$predicted.score
    
    # 更新最终预测结果
    final_df$predicted.label[match(group_cells, final_df$cell_id)] <- group_labels
    final_df$predicted.score[match(group_cells, final_df$cell_id)] <- group_scores
    
    # 为当前组的所有列添加前缀（除了cell_id）
    prefix <- gsub("&", "_and_", group)  # 替换特殊字符
    colnames(group_data) <- ifelse(
      colnames(group_data) == "cell_id",
      "cell_id",
      paste0(prefix, "_", colnames(group_data))
    )
    
    # 合并详细预测结果
    final_df <- merge(final_df, group_data, by = "cell_id", all.x = TRUE)
  }
  
  # 确保行顺序与输入一致
  final_df <- final_df[match(cell_ids, final_df$cell_id), ]
  
  # 新增：计算置信度分数
  if (!is.null(ci_gs)) {
    message("Calculating confidence scores...")
    
    # 创建所有需要检查的标记基因列表
    all_conf_genes <- unique(unlist(ci_gs))
    
    # 提取这些基因的表达矩阵（二值化：>0 表示表达）
    # 确保使用原始表达矩阵，并且细胞顺序与final_df一致
    conf_expr <- GetAssayData(object, slot = "data")[intersect(all_conf_genes, rownames(object)), cell_ids, drop = FALSE] > 0
    
    # 初始化置信度分数向量
    confidence_scores <- rep(0, length(cell_ids))
    names(confidence_scores) <- cell_ids
    
    # 对每种细胞类型处理
    for (cell_type in names(ci_gs)) {
      # 获取该细胞类型的标记基因
      marker_genes <- ci_gs[[cell_type]]
      valid_genes <- intersect(marker_genes, rownames(conf_expr))
      
      if (length(valid_genes) > 0) {
        # 计算每个细胞表达该类型标记基因的数量
        expr_count <- colSums(conf_expr[valid_genes, , drop = FALSE])
        
        # 找到预测为该类型的细胞
        predicted_cells <- final_df$cell_id[final_df$predicted.label == cell_type]
        
        # 更新这些细胞的置信度分数
        if (length(predicted_cells) > 0) {
          cell_expr_count <- expr_count[predicted_cells]
          
          # 根据表达数量分配置信度
          cell_confidence <- rep(0, length(cell_expr_count))
          cell_confidence[cell_expr_count == 5] <- 5
          cell_confidence[cell_expr_count == 4] <- 4
          cell_confidence[cell_expr_count == 3] <- 3
          cell_confidence[cell_expr_count == 2] <- 2
          cell_confidence[cell_expr_count == 1] <- 1
          
          confidence_scores[predicted_cells] <- cell_confidence
        }
      }
    }
    
    # 处理未在ci_gs中的预测类型
    missing_types <- setdiff(unique(final_df$predicted.label), names(ci_gs))
    if (length(missing_types) > 0) {
      missing_cells <- final_df$cell_id[final_df$predicted.label %in% missing_types]
      confidence_scores[missing_cells] <- NA
    }
    
    # 添加置信度列到final_df
    final_df$Confidence <- confidence_scores[cell_ids]
    
    # 将置信度列移到predicted.score后面
    col_order <- c("cell_id", "predicted.label", "predicted.score", "Confidence", "group")
    
    # 如果使用聚类分组，添加cluster列
    if (use_cluster) {
      col_order <- c(col_order, "cluster")
    }
    
    col_order <- c(col_order, pan_types)
    other_cols <- setdiff(colnames(final_df), col_order)
    final_df <- final_df[, c(col_order, other_cols)]
  } else {
    # 将预测标签列移到最前面
    col_order <- c("cell_id", "predicted.label", "predicted.score", "group")
    
    # 如果使用聚类分组，添加cluster列
    if (use_cluster) {
      col_order <- c(col_order, "cluster")
    }
    
    col_order <- c(col_order, pan_types)
    other_cols <- setdiff(colnames(final_df), col_order)
    final_df <- final_df[, c(col_order, other_cols)]
  }
  
  # 添加标记基因信息（如果需要）
  if (include_gs) {
    # 获取标记基因列表
    marker_info <- .extract_gs(gs, wt_gs)
    attr(final_df, "marker_genes") <- marker_info
    
    # 添加标记基因表达量到数据框
    message("Adding marker gene expression to output...")
    
    # 获取所有唯一的标记基因
    all_marker_genes <- unique(unlist(marker_info))
    
    # 提取表达矩阵（确保使用相同的cell_ids顺序）
    expr_matrix_full <- GetAssayData(object, slot = "data")[, cell_ids, drop = FALSE]
    
    # 为每个细胞类型添加其标记基因
    for (celltype in names(marker_info)) {
      genes <- marker_info[[celltype]]
      valid_genes <- intersect(genes, rownames(expr_matrix_full))
      
      if (length(valid_genes) > 0) {
        # 提取这些基因的表达矩阵
        celltype_expr <- as.matrix(expr_matrix_full[valid_genes, , drop = FALSE])
        
        # 转置矩阵：行->细胞，列->基因
        celltype_expr_t <- t(celltype_expr)
        
        # 添加细胞类型前缀到基因名（列名）
        colnames(celltype_expr_t) <- paste0(celltype, "_", colnames(celltype_expr_t))
        
        # 添加到最终数据框
        final_df <- cbind(final_df, celltype_expr_t)
      }
    }
    message("Added expression data for ", length(all_marker_genes), " marker genes")
  }
  
  setTxtProgressBar(pb_total, 6)
  Sys.sleep(0.1)
  close(pb_total)
  
  message("\nCell type assignment completed successfully!")
  message("Total cells processed: ", nrow(final_df))
  message("Total columns in output: ", ncol(final_df))
  
  return(final_df)
}

.cal_prob <- function(expr_matrix, gs, wt_gs, 
                      pan_scores) {
  n_cells <- ncol(expr_matrix)
  n_types <- length(gs)
  cell_ids <- colnames(expr_matrix)
  
  # 初始化概率矩阵
  prob_matrix <- matrix(1/n_types, nrow = n_cells, ncol = n_types,
                        dimnames = list(cell_ids, names(gs)))
  
  # 处理marker权重
  calculate_scientific_weights <- function(weight_levels) {
    weight_values <- sapply(weight_levels, function(level) {
      if (is.numeric(level)) return(level)
      switch(tolower(level),
             "high" = 1.0,
             "medium" = 0.7,
             "low" = 0.3,
             1.0)
    })
    weight_values / mean(weight_values)
  }
  
  # 创建权重矩阵 (仅使用gs中的基因)
  all_marker_genes <- unique(unlist(gs))
  weight_matrix <- matrix(0, nrow = n_types, ncol = length(all_marker_genes),
                          dimnames = list(names(gs), all_marker_genes))
  
  # 步骤1: 初始化所有基础标记基因的权重为low (0.3)
  for (type in names(gs)) {
    weight_matrix[type, gs[[type]]] <- 0.3
  }
  
  # 步骤2: 应用用户提供的权重 (覆盖默认值)
  if (!is.null(wt_gs) && length(wt_gs) > 0) {
    for (type in names(wt_gs)) {
      if (type %in% names(gs)) {
        weights <- wt_gs[[type]]
        sci_weights <- calculate_scientific_weights(weights)
        
        # 仅处理存在于基础标记基因中的基因
        valid_genes <- intersect(names(weights), gs[[type]])
        if (length(valid_genes) > 0) {
          weight_matrix[type, valid_genes] <- sci_weights[valid_genes]
        }
      }
    }
  }
  
  # 计算细胞类型概率
  for (i in seq_len(n_types)) {
    type <- names(gs)[i]
    relevant_genes <- gs[[type]]
    valid_genes <- intersect(relevant_genes, rownames(expr_matrix))
    
    if (length(valid_genes) > 0) {
      weights <- weight_matrix[type, valid_genes]
      expr_vals <- expr_matrix[valid_genes, , drop = FALSE]
      expr_vals[expr_vals < 0] <- 0
      
      weighted_geo_mean <- exp(colSums(weights * log1p(expr_vals)) / sum(weights))
      prob_matrix[, i] <- weighted_geo_mean
    } else {
      prob_matrix[, i] <- 0
    }
  }
  
  # Softmax归一化
  prob_matrix <- exp(prob_matrix - matrixStats::rowMaxs(prob_matrix))
  prob_matrix <- prob_matrix / rowSums(prob_matrix)
  
  # 生成结果
  results <- data.frame(
    cell_id = cell_ids,
    predicted.label = colnames(prob_matrix)[max.col(prob_matrix)],
    predicted.score = matrixStats::rowMaxs(prob_matrix),
    stringsAsFactors = FALSE
  )
  
  # 添加概率矩阵
  results <- cbind(results, as.data.frame(prob_matrix))
  
  return(results)
}

.extract_gs <- function(gs, wt_gs) {
  marker_info <- list()
  
  for (celltype in names(gs)) {
    # 获取基础标记基因
    base_genes <- gs[[celltype]]
    
    # 如果有权重信息，获取加权基因
    weighted_genes <- if (!is.null(wt_gs) && celltype %in% names(wt_gs)) {
      names(wt_gs[[celltype]])
    } else {
      NULL
    }
    
    # 确定最终使用的标记基因
    if (!is.null(weighted_genes)) {
      # 取基础基因和加权基因的交集
      final_genes <- intersect(base_genes, weighted_genes)
      if (length(final_genes) == 0) {
        warning("No overlapping marker genes for celltype: ", celltype,
                ". Using all base markers.")
        final_genes <- base_genes
      }
    } else {
      final_genes <- base_genes
    }
    
    marker_info[[celltype]] <- final_genes
  }
  
  return(marker_info)
}
